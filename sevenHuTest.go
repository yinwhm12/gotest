package main

import "gotest/algorithm"

//测试 对胡
func main()  {
	//a := []int{101,101,102,102,103,103,202,202,205,205,203,203,203,401}//hu 5对 3个一个 王牌1 5对
	//a := []int{101,101,102,102,103,103,202,202,205,205,207,207,209,401}//hu 6对 单一个 王牌1 6对
	//a := []int{101,101,101,101,103,103,202,202,205,205,207,207,209,401}//hu 4对 4个的一个 单的一个 王牌1 4对
	//a := []int{101,101,101,101,103,103,202,202,205,205,207,207,209,401}//hu 4对 4个的一个 单的一个 王牌1 4对
	//a := []int{101,101,101,101,103,103,202,202,205,205,207,207,207,401}//hu 4个的1 3个的1 王牌1 3对
	//a := []int{101,101,101,101,103,103,202,202,205,207,207,207,207,401}//hu 4个的2个 单的1个 王牌1 2对
	//a := []int{101,101,101,101,103,103,202,202,205,207,207,207,207,401}//hu 4个的2个 单的1个 王牌1 2对
	//a := []int{101,101,101,101,103,103,202,202,202,207,207,207,207,401}//hu 4个的2个 3个的1个 王牌1 1对
	//a := []int{101,101,101,101,103,202,202,202,202,207,207,207,207,401}//hu 4个的3个 单个的1 王牌1

	//a := []int{101,101,103,103,202,202,207,207,208,208,209,209,401,401}//hu 双王当 6对
	//a := []int{101,101,103,103,202,202,207,207,208,208,209,301,401,401}//hu  5对 单个的2 双王
	//a := []int{101,101,103,103,202,202,207,207,208,208,208,301,401,401}//hu 4对 三个的一个 双王
	//a := []int{101,101,101,101,202,202,207,207,208,208,209,209,401,401}//hu 4对 4个的一个 双王
	//a := []int{101,101,101,202,202,207,207,208,208,208,209,209,401,401}//hu 3对 3个的2个 双王
	//a := []int{101,101,105,202,202,207,207,208,208,208,208,209,401,401}//hu 3对 4个的一个 2个单 双王
	//a := []int{101,101,105,105,207,207,207,207,208,208,208,208,401,401}//hu 2对 4个的2个 单的2个 2个单 双王
	//a := []int{101,101,105,105,206,207,207,207,208,208,208,208,401,401}//hu 2对 4个的1个 3个的1个 1个单的 双王
	//a := []int{101,101,101,101,207,207,207,207,208,208,208,208,401,401}//hu 4个的3个 双王
	//a := []int{101,101,101,101,207,207,207,207,208,208,208,209,401,401}//hu 4个的2个 3个的1个 单一个 双王
	a := []int{101,101,101,101,207,207,207,207,208,208,209,301,401,401}//hu 1对 4个的2个 3个的0 单的2个 双王


	//a := []int{101,101,102,102,207,207,208,208,301,301,301,401,401,401}//hu 已有4个对 有3个1 可以形成一个杠 3王
	//a := []int{101,101,102,102,207,207,208,208,301,302,303,401,401,401}//hu 已有4个对,3个单 3王
	//a := []int{101,101,102,102,207,207,208,208,208,302,303,401,401,401}//hu 已有3个 且3个的有一个c[3]==1 单的2个 3王
	//a := []int{101,101,102,102,207,207,208,208,208,208,303,401,401,401}//hu 4个的1个 单的一个 3王
	//a := []int{101,101,102,102,102,207,207,207,208,208,208,401,401,401}//hu 有一对 且3个3的 3王
	//a := []int{102,102,102,102,207,207,207,208,208,209,301,401,401,401}//hu 有一对 4个的1个 3个的1个 单个的2个 3王



	var m map[int]int
	m = make(map[int]int)
	algorithm.CountCards(a,m,401)
	c := algorithm.EndOriginalCountCards(m)
	switch m[1000] {
	case 3:
		algorithm.HuBySevenThreeW(len(a),c)
	case 2:
		algorithm.HuBySevenTwoW(len(a),c)
	case 1:
		algorithm.HuBySevenOneW(len(a),c)
	default:
		algorithm.HuBySevenZeroW(len(a),c)
	}
}
